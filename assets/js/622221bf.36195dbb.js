"use strict";(self.webpackChunkmetapage_docs=self.webpackChunkmetapage_docs||[]).push([[184],{1942:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/dynamic-leaderboards.23f01857-9bb5-80d7-98d0-d64308174b08-82a7c5ccc1ce121d1f0f9c169a892483.png"},28453:(e,a,t)=>{t.d(a,{R:()=>i,x:()=>s});var n=t(96540);const o={},r=n.createContext(o);function i(e){const a=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(r.Provider,{value:a},e.children)}},68574:e=>{e.exports=JSON.parse('{"permalink":"/blog/dynamic-leaderboards","source":"@site/blog/dynamic-leaderboards.mdx","title":"Dynamic Configurable Live Leaderboards of Workflows","description":"Problem: evaluating AI models and similar tools is time consuming, often bespoke, replicates work done by others, and is difficult to update.","date":"2025-07-29T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Dion Whitehead","title":"Creator of Metapages","url":"https://github.com/metapages","email":"hey@metapage.io","socials":{"github":"https://github.com/dionjwa"},"imageURL":"https://github.com/dionjwa.png","key":"dion","page":null}],"frontMatter":{"title":"Dynamic Configurable Live Leaderboards of Workflows","sidebar_position":0,"slug":"/dynamic-leaderboards","date":"2025-07-29T00:00:00.000Z","authors":["dion"],"hide_table_of_contents":true},"unlisted":false,"nextItem":{"title":"MESH (Molecular Evaluation Science Hub)","permalink":"/blog/mesh"}}')},70722:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>d});var n=t(68574),o=t(74848),r=t(28453);const i={title:"Dynamic Configurable Live Leaderboards of Workflows",sidebar_position:0,slug:"/dynamic-leaderboards",date:new Date("2025-07-29T00:00:00.000Z"),authors:["dion"],hide_table_of_contents:!0},s=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Example web-first, dynamic live leaderboard",id:"23f018579bb580588e87d950e132d8c2",level:2},{value:"Notable features",id:"23f018579bb5809cac13e3bce12122bf",level:3}];function c(e){const a={a:"a",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(a.p,{children:[(0,o.jsx)(a.strong,{children:"Problem:"})," evaluating AI models and similar tools is time consuming, often bespoke, replicates work done by others, and is difficult to update."]}),"\n",(0,o.jsxs)(a.p,{children:[(0,o.jsx)(a.strong,{children:"Solution:"})," ",(0,o.jsx)(a.em,{children:"web-first,"})," automated, dynamic leaderboards, where the leaderboard entries are fully functional workflows, and the results are automatically collated and presented. The leaderboard is itself a dynamic, live, workflow."]}),"\n",(0,o.jsx)(a.h2,{id:"23f018579bb580588e87d950e132d8c2",children:"Example web-first, dynamic live leaderboard"}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.a,{href:"https://metapage.io/m/ab7a2dc814fa46fabb2aafac75061583",children:"https://metapage.io/m/ab7a2dc814fa46fabb2aafac75061583"})}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.img,{src:t(1942).A+"",width:"3344",height:"1136"})}),"\n",(0,o.jsx)(a.p,{children:"This example compares two methods of predicting a protein structure only using a FASTA file as a reference, using custom AI models. The two methods are:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:(0,o.jsx)(a.a,{href:"https://github.com/facebookresearch/esm",children:"esmfold"})}),"\n",(0,o.jsx)(a.li,{children:(0,o.jsx)(a.a,{href:"https://github.com/HeliXonProtein/OmegaFold/",children:"OmegaFold"})}),"\n"]}),"\n",(0,o.jsx)(a.h3,{id:"23f018579bb5809cac13e3bce12122bf",children:"Notable features"}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Dynamic competition inputs"})}),"\n",(0,o.jsx)(a.p,{children:"This leaderboard provides the target input sequence. This input is dynamic, if it changes, then all downstream workflows have their input updated"}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Dynamic workflow entries"})}),"\n",(0,o.jsx)(a.p,{children:"When the leaderboard entry workflows have their input updated, then the workflow can the be re-run with a single click, and the results are then updated automatically."}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"All source code and running containers are fully available and are self-contained components"})}),"\n",(0,o.jsx)(a.p,{children:"Unlike other leaderboards that at most might point to a github repo of code, all components are either self-contained javascript, or self-contained docker containers. Every component can be copied and taken individually, so that everyone benefits from the work of everyone else."}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"The leaderboard can be copied and run on your own workstations/infrastructure"})}),"\n",(0,o.jsxs)(a.p,{children:["Due to the ",(0,o.jsx)(a.a,{href:"https://github.com/metapages/compute-queues",children:"public compute grid infrastructure"}),", all workflows can be run by anyone, provided they have sufficient compute resources attached to their own compute queues."]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"The workflows are all shareable URLs"})}),"\n",(0,o.jsx)(a.p,{children:"Not installation needed, no configuration. Provided you have sufficient computation resources, the workflows run without any complex time-intensive steps, directly in the browser. Heavy compute is abstracted away."}),"\n",(0,o.jsx)(a.hr,{}),"\n",(0,o.jsx)(a.p,{children:"The future of human collaboration requires automation and open-sharing infrastructure."}),"\n",(0,o.jsx)(a.mermaid,{value:'flowchart LR\n  leaderboards[Leaderboards] --\x3e example[Example Leaderboard]\n  click leaderboards "/blog/mesh"\n  click example "/blog/dynamic-leaderboards"\n  style example fill:#fff,stroke:#999999,stroke-width:2px,color:#000'})]})}function h(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);